<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í€´ì¦ˆ ì„¸ì…˜</title>
    <style>
    .hidden { display: none; }
    </style>
</head>
<body>
  <button id="outBtn" onclick="location.href='/'">ë‚˜ê°€ê¸°</button>
  <button id="forceSkipBtn" class="hidden">ê°•ì œìŠ¤í‚µ</button>
  <button id="voteSkipBtn" class="hidden">ìŠ¤í‚µíˆ¬í‘œ</button>
  <p id="skipStatus" class="hidden">ìŠ¤í‚µ íˆ¬í‘œ: 0 / 0</p>
    
  <h1>ì‹¤ì‹œê°„ í€´ì¦ˆ ì„¸ì…˜</h1>

    <!-- âœ… ëŒ€ê¸° í™”ë©´ -->
  <div id="lobbySection">
    <h2>ê²Œì„ ëŒ€ê¸° ì¤‘...</h2>
    <p>ì´ˆëŒ€ì½”ë“œ: <span id="inviteCode">ë¡œë”©ì¤‘...</span></p>
    <p>ì°¸ê°€ì ëª©ë¡:</p>
    <ul id="playerList"></ul>
    <button id="startBtn" class="hidden">ê²Œì„ì‹œì‘</button>
  </div>

  <!-- âœ… ê²Œì„ í™”ë©´ -->
  <div id="gameSection" class="hidden">
    <p id="countdown">ë‚¨ì€ ì‹œê°„: </p>
    <div id="questionBox"></div>

    <div id="chatLog"></div>

    <form id="chatForm" onsubmit="event.preventDefault(); currentSendFunction();">
      <input type="text" id="chatInput" placeholder="ë©”ì„¸ì§€ ì…ë ¥">
      <button onclick="currentSendFunction();">ì „ì†¡</button>
    </form>

    <h2>í˜„ì¬ ì ìˆ˜íŒ</h2>
    <ul id="scoreboard"></ul>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="/js/CorrectUserManager.js"></script>
  <script>

    async function fetchWithAuth(url, options = {}) {
        options.credentials = 'include'; // Ensure cookies are sent

        let response = await fetch(url, options);

        if (response.status === 401) {
            // Try to refresh token
            const refreshResponse = await fetch('/auth/refresh', {
                method: 'POST',
                credentials: 'include'
            });

            if (refreshResponse.ok) {
                // Token refreshed, retry original request
                response = await fetch(url, options);
            } else {
                // Refresh failed, redirect to login
                alert('ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.');
                window.location.href = '/login';
                return; // Prevent further execution
            }
        }
        return response;
    }

    let currentSendFunction = sendMessage;
    let questions = [];
    let currentIndex = 0;
    let questionTimer = null;
    let host = null;
    let questionStartAt  = null;
    let countdownInterval = null;
    let hasAnswered = false;

    const socket = io();
    const sessionId = window.location.pathname.split('/').pop();
    let userId = null; // Will be set after successful session data load or from server
    let username = null; // Will be set after successful session data load or from server
    

    (async () => {
      try {
        const response = await fetchWithAuth('/my-info');
        if (!response.ok) {
          throw new Error('Failed to fetch user info');
        }
        const userData = await response.json();
        userId = userData._id;
        username = userData.username;

        socket.emit('joinSession', { sessionId });
      } catch (error) {
        console.error('Error fetching user info:', error);
        window.location.href = '/login';
      }
    })();

    function isHost() {
      return userId === host;
    }

    // âœ… ë°ì´í„° ë¡œë”© ì „ìš© í•¨ìˆ˜
    async function loadSessionData() {
      try {
        const res = await fetchWithAuth(`/game/session/${sessionId}`); // Changed to fetchWithAuth

        // ì‘ë‹µ ìƒíƒœ í™•ì¸
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({}));
          throw new Error(errorData.message || 'ì„¸ì…˜ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }

        const data = await res.json();

        // í•„ìˆ˜ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
        if (!data || !data.quiz || !Array.isArray(data.players)) {
          throw new Error('ì„¸ì…˜ ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        }

        // ìƒíƒœ ì´ˆê¸°í™”
        questions = data.quiz.questions;
        currentIndex = data.currentQuestionIndex;
        questionStartAt = new Date(data.questionStartAt);
        host = data.host;
        document.getElementById('inviteCode').textContent = data.inviteCode || 'ì—†ìŒ';

        // ì ìˆ˜íŒ ë° íˆ¬í‘œ ìƒíƒœ ë Œë”ë§
        renderScoreboard(data.players);
        renderSkipStatus(data.skipVotes?.length || 0, data.players?.length || 0);

        if (data.isStarted) {
          lobbySection.classList.add('hidden');
          gameSection.classList.remove('hidden');
          voteSkipBtn.classList.remove('hidden');
          document.getElementById('skipStatus').classList.remove('hidden');
          if (userId === host) {
            forceSkipBtn.classList.remove('hidden');
          }

          const correctUsernames = data.correctUsers?.[currentIndex];
          if (correctUsernames && Array.isArray(correctUsernames) && correctUsernames.length > 0) {
            CorrectUserManager.restoreFromData(correctUsernames);
          }

          // ì •ë‹µ ê³µê°œ ìƒíƒœë©´ UI ë³µì›
          if (data.revealedAt) {
            showQuestion({ silent: true });

            const answers = questions[currentIndex]?.answers;
            if (answers) {
              const p = document.createElement('p');
              p.textContent = `âœ… ì •ë‹µ ê³µê°œ: ${answers}`;
              p.style.color = 'green';
              document.getElementById('questionBox').appendChild(p);
            }

            const answerImage = questions[currentIndex]?.answerImageBase64;
            if (answerImage) {
              const img = document.createElement('img');
              img.src = answerImage;
              img.alt = 'ì •ë‹µ ì´ë¯¸ì§€';
              img.style.maxWidth = '300px';
              img.style.marginTop = '10px';
              document.getElementById('questionBox').appendChild(img);
            }

            window.__isRevealingAnswer = true;
            const elapsed = (Date.now() - new Date(data.revealedAt)) / 1000;
            const wait = Math.max(0, 5 - elapsed);
            setTimeout(() => {
              window.__isRevealingAnswer = false;
              if (isHost()) {
                socket.emit('nextQuestion', { sessionId, userId });
              }
            }, wait * 1000);
          } else {
            showQuestion();
          }
        }

      } catch (err) {
        console.error('âŒ ì„¸ì…˜ ë¡œë”© ì‹¤íŒ¨:', err);
        // "ì„¸ì…˜ ì—†ìŒ" ì˜¤ë¥˜ì¼ ê²½ìš°, ê²½ê³ ì°½ ì—†ì´ ë°”ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
        if (err.message === 'ì„¸ì…˜ ì—†ìŒ') {
          location.href = '/';
        } else {
          // ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì˜¤ë¥˜ëŠ” ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼
          alert(err.message || 'ì„¸ì…˜ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
          location.href = '/';
        }
      }
    }


    // âœ… ì ìˆ˜íŒ ë Œë”ë§ í•¨ìˆ˜
    function renderScoreboard(players) {
      const board = document.getElementById('scoreboard');
      board.innerHTML = '';

      // ì ìˆ˜ ê¸°ì¤€ ì •ë ¬
      players
        .filter(p => p.connected)
        .slice() // ì›ë³¸ ë°°ì—´ í›¼ì† ë°©ì§€
        .sort((a, b) => b.score - a.score)
        .forEach(p => {
          const li = document.createElement('li');
          li.textContent = `${p.username}: ${p.score}ì  (ë§ì¶˜ ë¬¸ì œ ìˆ˜ ${p.correctAnswersCount || 0}ê°œ)`;
          board.appendChild(li);
        });
    }

    // âœ… ìŠ¤í‚µ íˆ¬í‘œ ìƒíƒœ ë Œë”ë§
    function renderSkipStatus(voted, total) {
      document.getElementById('skipStatus').textContent = `ìŠ¤í‚µ íˆ¬í‘œ: ${voted} / ${total}`;
    }

    socket.on('session-ready', () => {
      loadSessionData(); // <--- ì´ˆê¸°í™” ì „ìš© í•¨ìˆ˜ë¡œ ë¶„ë¦¬
    });
    
    socket.on('scoreboard', ({ success, message, data }) => {
      if (!success) {
        console.error('âŒ ì ìˆ˜íŒ ë¡œë”© ì‹¤íŒ¨:', message);
        return;
      }
      renderScoreboard(data.players);
    });
    
    socket.on('choiceQuestionScoreboard', ({ success, message, data }) => {
      if (!success) {
        console.error('âŒ ì ìˆ˜íŒ ë¡œë”© ì‹¤íŒ¨:', message);
        return;
      }
      renderScoreboard(data.players);

      if (data.correctUsers && data.correctUsers.length > 0) {
        CorrectUserManager.setUsers(data.correctUsers);
      }

      setTimeout(() => {
        if (isHost()) {
          socket.emit('nextQuestion', { sessionId, userId });
        }
      }, 3000);
    });

    socket.on('voteSkipUpdate', ({ success, data, votes, total }) => {
      if (success === false && data === undefined) {
        // joinSessionì—ì„œ ì˜¤ëŠ” ê²½ìš°
        renderSkipStatus(votes, total);
      } else {
        // vote ì´ë²¤íŠ¸ì—ì„œ ì˜¤ëŠ” ê²½ìš°
        const el = document.getElementById('skipStatus');
        if (el && data) {
          el.textContent = `ìŠ¤í‚µ íˆ¬í‘œ: ${data.votes} / ${data.total}`;
        }
      }
    });

    const lobbySection = document.getElementById('lobbySection');
    const gameSection = document.getElementById('gameSection');
    const startBtn = document.getElementById('startBtn');
    const playerList = document.getElementById('playerList');
    const voteSkipBtn = document.getElementById('voteSkipBtn');
    const forceSkipBtn = document.getElementById('forceSkipBtn');
    
    // ì±„íŒ… ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
    fetchWithAuth(`/game/chat/${sessionId}`) // Changed to fetchWithAuth
      .then(res => res.json())
      .then(data => {
        const chatLog = document.getElementById('chatLog');
        data.messages.forEach(msg => {
          const p = document.createElement('p');
          p.innerHTML = `${msg.username}: ${msg.message}`;
          chatLog.appendChild(p);
        });
      })
      .catch(err => console.error('ì±„íŒ… ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', err));

    // ëŒ€ê¸°ì‹¤ ìˆ˜ì‹ 
    socket.on('waiting-room', ({ success, data, message }) => {

      if (!success) {
        console.error('âŒ ëŒ€ê¸°ì‹¤ ë¡œë”© ì‹¤íŒ¨:', message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜');
        return;
      }

      const { host: newHost, players, isStarted } = data;

      host = newHost;
      
      playerList.innerHTML = '';
      players
        .filter(p => p.connected)
        .forEach(({ username }) => {
          const li = document.createElement('li');
          li.textContent = username;
          playerList.appendChild(li);
        });

      // ğŸ”¥ userId ê¸°ì¤€ ë¹„êµ
      if (userId === host && !isStarted) {
        startBtn.classList.remove('hidden');
        startBtn.onclick = () => {
          socket.emit('startGame', { sessionId, userId });
          startBtn.disabled = true;
        };
        forceSkipBtn.classList.add('hidden');
      } else {
        startBtn?.classList.add('hidden');
        forceSkipBtn.classList.add('hidden');
      }
    });

    // ê²Œì„ ì‹œì‘ë¨
    socket.on('game-started', ({ success, data, message }) => {
        if (!success) {
          console.error('âŒ ê²Œì„ ì‹œì‘ ì‹¤íŒ¨:', message);
          alert(message || 'ê²Œì„ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
          return;
        }

        const { quiz, host: newHost, questionStartAt: startAt } = data;

        if (!quiz || !Array.isArray(quiz.questions)) {
          console.error('âŒ ì˜ëª»ëœ í€´ì¦ˆ êµ¬ì¡°:', quiz);
          alert('í€´ì¦ˆ ë°ì´í„°ê°€ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤.');
          return;
        }

      host = newHost;
      questions = quiz.questions;
      currentIndex = 0;
      questionStartAt = new Date(startAt);

      lobbySection.classList.add('hidden');
      gameSection.classList.remove('hidden');
      voteSkipBtn.classList.remove('hidden');
      document.getElementById('skipStatus').classList.remove('hidden');
      
      if (userId === host) {
          forceSkipBtn.classList.remove('hidden');
      };

      showQuestion();
    });

    // ìƒˆë¡œìš´ í˜¸ìŠ¤íŠ¸ì„ ì •
    socket.on('host-updated', ({ success, data, message }) => {
      if (!success) {
        console.error('âŒ í˜¸ìŠ¤íŠ¸ ê°±ì‹  ì‹¤íŒ¨:', message);
        return;
      }

      const { host: newHost } = data;
      host = data.host;

      const isGameStarted = !gameSection.classList.contains('hidden');

      if (host === '__NONE__') {
        forceSkipBtn.classList.add('hidden');
        startBtn?.classList.add('hidden');
      } else if (userId === host) {

        if (isGameStarted) {
          forceSkipBtn.classList.remove('hidden');
        } else {
          forceSkipBtn.classList.add('hidden'); // âœ… ëŒ€ê¸°ì‹¤ì´ë©´ ìˆ¨ê¸°ê¸°
        }

        if (!isGameStarted) {
          startBtn?.classList.remove('hidden');
        } else {
          startBtn?.classList.add('hidden');
        }

      } else {
        forceSkipBtn.classList.add('hidden');
        startBtn?.classList.add('hidden');
      }
    });

    //ìŠ¤í‚µíˆ¬í‘œ
    voteSkipBtn.addEventListener('click', async () => {
      socket.emit('voteSkip', { sessionId });
    });

    //ë°©ì¥ ê°•ì œìŠ¤í‚µ
    forceSkipBtn.addEventListener('click', () => {
      socket.emit('forceSkip', { sessionId });
    });
  
    //ë¬¸ì œ ë„˜ê¸°ê¸°
    socket.on('next', ({ success, data, message }) => {
      if (!success) {
        console.error('âŒ ë‹¤ìŒ ë¬¸ì œ ì „ì†¡ ì‹¤íŒ¨:', message);
        return;
      }

      const { index, questionStartAt: startAt, totalPlayers } = data;

      currentIndex = index;
      questionStartAt  = new Date(startAt); 
      document.getElementById('skipStatus').textContent = `ìŠ¤í‚µ íˆ¬í‘œ: 0 / ${totalPlayers}`;
      showQuestion();
    });

    //ë©”ì„¸ì§€ ì…ë ¥ì‹œ ì •ë‹µì¸ì§€ ì¼ë°˜ì±„íŒ…ì¸ì§€ íŒë³„
    function sendMessage() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      input.value = '';

      if (!message) return;

      const rawAnswers = questions[currentIndex].answers || []; // ë°°ì—´
      const answers = rawAnswers.map(a => a.replace(/\s+/g, '').toLowerCase());
      const userInput = message.replace(/\s+/g, '').toLowerCase();
      
      const isCorrect = answers.includes(userInput);

      if (!window.__isRevealingAnswer && isCorrect) {
        socket.emit('correct', { sessionId });
      } else {
        socket.emit('chatMessage', { sessionId, message });
      }
    }

    //ë©”ì„¸ì§€ ì…ë ¥ì‹œ ì •ë‹µì¸ì§€ ì¼ë°˜ì±„íŒ…ì¸ì§€ íŒë³„
    function choiceQuestionSendMessage() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      input.value = '';

      if (!message) return;

      const userInput = message.replace(/\s+/g, '').toLowerCase();
      
        socket.emit('chatMessage', { sessionId, message });
    }

    socket.on('chat', ({ user, message }) => {
      const chatLog = document.getElementById('chatLog');
      const p = document.createElement('p');
      p.innerHTML = `${user}: ${message}`;
      chatLog.appendChild(p);
    });

    //ì •ë‹µì‹œ ì¤‘ë³µ ë°©ì§€í•˜ì—¬ ì¶œë ¥í•œë‹¤
    socket.on('correct', ({ success, data, message }) => {
      if (!success) {
        console.error('âŒ ì •ë‹µ ìˆ˜ì‹  ì‹¤íŒ¨:', message);
        return;
      }

      const { username } = data;
      CorrectUserManager.addUser(username);

      const chatLog = document.getElementById('chatLog');
      const p = document.createElement('p');
      p.innerHTML = `${username}: ${username}ë‹˜ì´ ì •ë‹µì„ ë§í˜”ìŠµë‹ˆë‹¤! ğŸ‰`;
      chatLog.appendChild(p);
    });

    socket.on('end', ({ success, message }) => {
        if (!success) {
          console.error('âŒ í€´ì¦ˆ ì¢…ë£Œ ì˜¤ë¥˜:', message);
          return;
        }

        alert(message || 'í€´ì¦ˆê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!');
        });

    socket.on('revealAnswer_Emit', ({ success, data, message }) => {
      if (!success) {
        console.error('âŒ ì •ë‹µ ê³µê°œ ì‹¤íŒ¨:', message);
        return;
      }

      const { answers, answerImage, revealedAt } = data;

      showAnswer({
        answers,
        answerImageBase64: answerImage,
        revealedAt
      });
    });

    function showAnswer({ answers, answerImageBase64, revealedAt }) {
      const box = document.getElementById('questionBox');

      // ì •ë‹µ í…ìŠ¤íŠ¸
      if (answers) {
        const p = document.createElement('p');
        p.style.color = 'green';
        p.textContent = `âœ… ì •ë‹µ ê³µê°œ: ${answers}`;
        box.appendChild(p);
      }

      // ì •ë‹µ ì´ë¯¸ì§€
      if (answerImageBase64) {
        try {
          const img = document.createElement('img');
          img.src = answerImageBase64;
          img.alt = 'ì •ë‹µ ì´ë¯¸ì§€';
          img.style.maxWidth = '300px';
          img.style.marginTop = '10px';
          box.appendChild(img);
        } catch (err) {
          console.error('âŒ ì •ë‹µ ì´ë¯¸ì§€ ë Œë”ë§ ì‹¤íŒ¨:', err);
        }
      }

      window.__isRevealingAnswer = true;

      const elapsed = (Date.now() - new Date(revealedAt).getTime()) / 1000;
      const waitTime = Math.max(0, 5 - elapsed);

      setTimeout(() => {
        window.__isRevealingAnswer = false;
        if (isHost()) {
          socket.emit('nextQuestion', { sessionId, userId });
        }
      }, waitTime * 1000);
    }

    socket.on('forceRedirect', (data) => {
      alert('ì„¸ì…˜ì´ ì¢…ë£Œë˜ì–´ ë©”ì¸ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤.');
      window.location.href = data.url || '/';
    });

    function showQuestion({ silent = false } = {}) {
      const box = document.getElementById('questionBox');
      const question = questions[currentIndex];
      const answers = questions[currentIndex]?.answers;

      let choiceQuestion = questions[currentIndex]?.incorrectAnswers;

      if (!question) {
        box.innerHTML = '<p>ë¬¸ì œë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
        return;
      }

      hasAnswered = false;

      CorrectUserManager.clear();

      let html = `<h2>ë¬¸ì œ #${currentIndex + 1}</h2><br>`;

      if(choiceQuestion && choiceQuestion.length > 0) {
        try {
          currentSendFunction = choiceQuestionSendMessage;
          html += `<p>${question.text}</p>`;
            // ê°ê´€ì‹ ì„ íƒì§€ ë§Œë“¤ê¸°
            html += `<div style="margin-top: 20px;">`;
            html += `<h3>ë‹¤ìŒ ì¤‘ ì •ë‹µì„ ì„ íƒí•˜ì„¸ìš”:</h3>`;
            
            // ì •ë‹µê³¼ ì˜¤ë‹µì„ í•©ì¹˜ê¸°
            const allChoices = [];
            
            // ì •ë‹µë“¤ ì¶”ê°€
            if (answers && answers.length > 0) {
                const randomAnswer = answers[Math.floor(Math.random() * answers.length)];
                allChoices.push(randomAnswer);
            }
            
            // ì˜¤ë‹µë“¤ ì¶”ê°€
            if (choiceQuestion && choiceQuestion.length > 0) {
                choiceQuestion.forEach(incorrect => allChoices.push(incorrect));
            }
            
            // ë°°ì—´ ì„ê¸° (Fisher-Yates ì•Œê³ ë¦¬ì¦˜)
            for (let i = allChoices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allChoices[i], allChoices[j]] = [allChoices[j], allChoices[i]];
              }
            
            allChoices.forEach((choice, index) => {
                html += `
                    <button onclick="selectChoice('${choice.replace(/'/g, "\\'")}')" 
                            style="display: block; margin: 8px 0; padding: 12px; width: 400px; 
                                   background: #f0f0f0; border: 2px solid #ccc; border-radius: 8px; 
                                   cursor: pointer; font-size: 16px; text-align: left;">
                        ${index + 1}. ${choice}
                    </button>
                `;
                });
                html += `</div>`;
        } catch (error) {
          console.error('ê°ê´€ì‹ ë¬¸ì œë¥¼ ë¶ˆëŸ¬ì˜¬ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')
        }
      } else {
        currentSendFunction = sendMessage;
        html += `<p>${question.text}</p>`;
      }
      if (question.imageBase64) {
        html += `<img src="${question.imageBase64}" alt="ë¬¸ì œ ì´ë¯¸ì§€" style="max-width: 300px;">`;
      }

      if (question.youtubeUrl) {
        html += `<div style="margin-top: 10px;">
                  <iframe width="560" height="315"
                    src="${question.youtubeUrl}"
                    frameborder="0" allowfullscreen></iframe>
                </div>`;
      }

      box.innerHTML = html;

      const correctUsernames = questions[currentIndex]?.correctUsers;
        if (correctUsernames && correctUsernames.length > 0) {
          CorrectUserManager.restoreFromData(correctUsernames);
        }

      if (silent) return;

      // ê¸°ì¡´ íƒ€ì´ë¨¸ ì œê±°
      if (questionTimer) clearTimeout(questionTimer);
      if (countdownInterval) clearInterval(countdownInterval);

      const timeLimit = question.timeLimit || 90;

      // âœ… ì •í™•í•œ ì‹œê°„ ê³„ì‚° (í•œ ë²ˆë§Œ new Date ì‚¬ìš©)
      const elapsed = (Date.now() - questionStartAt.getTime()) / 1000;
      let remaining = Math.max(0, Math.floor(timeLimit - elapsed));

      const countdownEl = document.getElementById('countdown');
      if (countdownEl) countdownEl.textContent = `ë‚¨ì€ ì‹œê°„: ${remaining}ì´ˆ`;

      countdownInterval = setInterval(() => {
        remaining--;
        if (countdownEl) countdownEl.textContent = `ë‚¨ì€ ì‹œê°„: ${remaining}ì´ˆ`;
        if (remaining <= 0) {
          clearInterval(countdownInterval);
        }
      }, 1000);

      questionTimer = setTimeout(() => {
        if (isHost()) {
          socket.emit('revealAnswer', { sessionId });
        }
      }, remaining * 1000);
    }

    function selectChoice(choice) {
        if (hasAnswered) return;
        
        hasAnswered = true;
        
        const rawAnswers = questions[currentIndex].answers || [];
        const answers = rawAnswers.map(a => a.replace(/\s+/g, '').toLowerCase());
        const userInput = choice.replace(/\s+/g, '').toLowerCase();
        
        const isCorrect = answers.includes(userInput);

        if (!window.__isRevealingAnswer && isCorrect) {
            socket.emit('choiceQuestionCorrect', { sessionId });
        } else {
            socket.emit('choiceQuestionIncorrect', { sessionId });
        }
    }

  </script>
</body>
</html>